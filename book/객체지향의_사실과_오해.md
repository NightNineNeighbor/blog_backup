# 객체지향의 사실과 오해

객체지향 패러다임의 목적은 현실 세계를 모방하는 것이 아니라 현실 세계를 기반으로 세로운 세계를 창조하는 것이다.

##협력하는 객체들의 공동체

> 역할, 협력, 책임
>
> **객체**는 시스템의 행위를 구현하기 위해 다를 객체외 **협력**한다. 각 객체는 협력 내에서 정해진 **역할**을 수행하며 역할은 관련된 **책임**의 집합이다. 

특정한 역할은 특정한 책임을 암시한다.

어떤 객체도 섬이 아니다.

객체는 다른 객체의 명령에 복종하는 것이 아니라 요청에 응답할 뿐이다.

객체 = 상태(데이터) + 행동(프로세스)

객체는 협력을 위해 메시지를 전송하고, 수신한다.

메서드 : 객체가 수신된 메시지를 처리하는 방법

## 이상한 나라의 객체

> 객체지향 패러다임은 지식을 추상화하고 추상화한 지식을 객체 안에 캡슐화함으로써 실세계 문제에 내제된 복잡성을 관리하려고 한다. 객체를 발견하고 창조하는 것은 행동과 지식을 구조화하는 문제다. -레베카 워프스브록

> 상태, 행동 식별자

**객체**란 식별 가능한 개체 또는 사물이다. 객체는 구체적일 수도 있고, 추상적일 수도 있다. 객체는 구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태를 가진다. 소프트웨어 안에서 객체는 저장된 상태와 실행 가능한 코드를 통해 구현된다.

객체란 자신의 상태를 스스로 관리하는 ***자율적***인 존재이다. ->이 때문에 setter, getter가 지양되는 듯 하다.

​	-> 의인화(anthropomorphism)

**상태**는 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현한다. 객체의 상태는 객체에 존재하는 정직인 프로퍼티와 동적인 프로퍼티 값으로 구성된다. 객체의 프로퍼티는 단순한 값과 다른 객체를 참조하는 링크로 구분할 수 있다.

객체의 행동은 과거의 **상태**에 따라 다른 결과를 부른다.

**프로퍼티** : 객체의 상태를 구성하는 모든 특징, 정적

**프로퍼티 값** : 프로퍼티의 값, 동적 ex) 나이 : 27

**행동**이란 외부의 요청 또는 수신된 메시지에 응답하기 위해 반응하는 활동이다. 행동의 결과로 객체는 자신의 상태를 변경하거나 다른 객체에 메시지를 전달할 수있다. 객체는 행동을 통해 다른 객체의 협력에 참여하므로 행동은 외부에 가시적이어야 한다.

**식별자**란 어떤 객체를 다른 객체와 구분하는 데 사용하는 객체의 프로퍼티이다. 값은 식별자를 가지지 않기 때문에 상태를 이용한 *동등성equality* 검사를 통해 두 인스턴슬르 비교해야 한다. 객체는 상태가 변경될 수 있기 때문에 식별자를 이용한 *동일성identical* 검사를 통해 두 인스턴스를 비교할 수 있다.  -> pointer??? 같은 heap 위치???

쿼리 : 객체의 상태를 조회함

명령 : 객체의 상태를 변화시킴

> 행동이 상태를 결정한다

->상태를 먼저 결정할 경우 캡슐화가 저해된다.

->객체를 고립된 섬으로 만든다. 객체가 필요한 이유는 app내에서 다른 객체외 협력하기 위해서이다.

->객체의 행동은 객체가 협력에 참여하는 유일한 방법이다.

## 타입과 추상화

> 일단 컴퓨터를 조작하는 것이 추상화를 구축하고, 조작하고, 추론하는 것에 관한 모든 것이라는 것을 깨닫고 나면 (훌륭한) 컴퓨터 프로그램을 작성하기 위한 중요한 전제 조건은 추상화를 정확하게 다루는 능력이라는 것이 명확해진다. -키스 데블린

추상화는 목적에 부합하는 것이여야 한다.

> **추상화** 
> 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.
>
> * 구체적인 사물, 개념들 간의 공통점은 취하고 차이점은 버리는 일반화를 토앻 단순히 만든다.
> * 중용한 부분을 강조하기 위해 불필요한 세부사항을 제거한다.
>
> 모든 경우에서 추상화의 목적은 복잡성을 이해하기 쉬운 수준으로 단순화하는 것이다.

> 개념
>
> * 심볼 : 개념을 가리키는 간략한 이름, 명칭
> * 내연 : 개념의 완전한 정의
> * 외연 : 개념에 속하는 모든 객체의 집합

분류(classify) -> 자바의 클래스

> **타입**
>
> 타입은 개념이다.
>
> 타입은 개념과 동일하다. 따라서 타입이란 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 의미한다. 어떤 객체에 타입을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고 한다. 타입의 인스턴스는 타입을 구성하는 외연인 객체 집합의 일원이 된다.

어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 *행동*이다.

객체의 내부적인 표현은 외부로부터 철저히 감춰진다.

책임 주도 설계 > 데이터 주도 설계

> 타입의 계층
>
> 일반화/특수화 
>
> 슈퍼타입/서브타입 ex) 둥몰/고양이

객체지향에서 일반화/특수화를 결정하는 것은 객체의 상태를 표현하는 데이터가 아니라 행동이다.

## 역할, 책임, 협력

> 어떤 객체가 어떤 요청에 대해 대답해 줄 수 이썩나, 행동할 의무가 있는 경우 해당 객체가 **책임**을 가진다고 말한다.

* 하는 것 
  * 객체를 생성하거나 계산을 하는 등의 스스로 하는 것
  * 다른 객체의 행동을 시작하는 것
  * 다른 객체의 활동을 제어하고 조절하는 것
* 아는 것
  * 개인정인 정보에 관해 아는 것
  * 관련된 객체에 관해 아는 것
  * 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

객체의 책임을 이야기할 때는 일반적으로 외부 접근 가능한 공용 서비스의 관점에서 이야기한다. 즉, 책임은 객체의 외부에 제공해 줄 수 있는 정보(아는 것), 서비스(하는 것)의 목록이다. 따라서 책임은 객체의 **공용 인터페이스(public interface)**를 구성한다.

>책임을 수행하도록 요청을 보내는 것을 **메시지 전송(message-send)**라고 한다.

> 책임의 집합이 의미하는 것 : **역할**

역할의 개념을 사용하면 유사한 협력을 *추상화*해서 인지 과부화를 줄일 수 있다.

> 객체의 모양을 결정하는 **협력**

객체는 행위를 수행하며 협력에 참여하기 위해서다.

클래스와 클래스간의 관계를 표현하는 것이 아닌, 객체가 협력 안에서 어떤 책임과 역할을 수행할 것인지를 결정하는 것이다.

*TDD는 테스트가 아니라 설계를 위한 기법이다. TDD는 코드를 작성해 나가며 역할, 책임, 협력을 식별하고 적합한디 피드백 받는 것이다.*

## 책임과 메시지

> 의도는 "메시지"이다. 훌륭하고 성장 가능한 시스템을 만들기 위한 핵심은 모듈 내부의 속성과 행동이 어떤가보다는 모듈이 어떻게 커뮤니케이션하는가에 달려있다.

자율적 책임의 특징은 '어떻게(how)'해야 하는가가 아니라 '무엇(why)'을 해야 하는가를 설명한다는 것이다.

메시지를 기반으로 한 두 객체 사이의 낮은 결합도가 설계를 유연하고 확장 가능하며 재사용 가능하게 만드는 비결이다.

묻지 말고 시켜라 - 데메테르 법칙

> 인터페이스와 구현의 분리

객체가 수신할 수 있는 메시지의 목록 **인터페이스(interface)**

내부 구조와 작동 방식을 가리키는 용어는 **구현(implementation)**이다

훌륭한 객체란 구현을 모른체 인터페이스만으로 상호작용 할 수 있는 객체다.

객체의 자율성을 보존하기 위해 구현을 외부로부터 감추는 것을 **캡슐화**라고 한다.

## 객체 지도





